#!/usr/bin/perl

use strict;
use warnings;

my $USAGE = "Usage: $0 --directory <payload directory> rpm...\n";

use Getopt::Long;
use Fcntl qw(:mode);

my $directory;
my $output = ".";
my @rpms;

$ENV{LC_ALL} = "C";

GetOptions(
	"help|h" => sub { print $USAGE; exit; },
	"directory|d=s" => \$directory,
	"output|o=s" => \$output,
) or die $USAGE;
@rpms = @ARGV;
if (!@rpms) {
	print STDERR "$0: No packages given\n";
	die $USAGE;
}
if (!$directory || substr($directory, 0, 1) ne '/' || ! -d $directory) {
	print STDERR "$0: --directory must be an absolute path\n";
	die $USAGE;
}

sub query_array {
	my ($rpm, @tags) = @_;
	my @res;

	my $format = "[" . join("|", map { "\%{$_}" } @tags) . "\\n]";
	open(my $fh, '-|', "rpm", "-qp", "--qf", $format, $rpm)
		or die "rpm: $!\n";
	while (<$fh>) {
		chomp;
		my @t = split(/\|/, $_, -1);
		push(@res, \@t);
	}
	close($fh);
	return @res;
}

sub query_single {
	my ($rpm, $tag) = @_;
	my $res;

	open(my $fh, '-|', "rpm", "-qp", "--qf", "\%{$tag}\\n", $rpm)
		or die "rpm: $!\n";
	{
		local $/ = undef;
		$res = <$fh>;
	}
	chomp $res;
	close($fh);
	return $res;

}

# specfile dependency => rpm tag name
my %dep2tag = (
	conflicts => "conflict",
	obsoletes => "obsolete",
	provides => "provide",
	requires => "require",
	suggests => "suggests",
	supplements => "enhances",
);

# specfile scriptlet => rpm tag name
my %script2tag = (
	pre          => "prein",
	post         => "postin",
	preun        => "preun",
	postun       => "postun",
	pretrans     => "pretrans",
	posttrans    => "posttrans",
	verifyscript => "verifyscript",
	# FIXME: triggers
);

sub load_package {
	my $rpm = shift;
	my %res;

	for my $tag (qw(name version release arch sourcerpm license group summary description)) {
		$res{$tag} = query_single($rpm, $tag);
	}
	my @files;
	my @list = query_array($rpm, qw(filenames fileflags filemodes fileusername filegroupname filesizes));
	for my $file (@list) {
		push(@files, {
				name => $file->[0],
				flags => $file->[1],
				mode => $file->[2],
				owner => $file->[3],
				group => $file->[4],
				size => $file->[5],
		});
	}
	$res{files} = \@files;
	while (my ($dep, $tag) = each(%dep2tag)) {
		my @deps;
		my @list = query_array($rpm, "${tag}name", "${tag}flags", "${tag}version");
		for my $d (@list) {
			push(@deps, {
					name => $d->[0],
					flags => $d->[1],
					version => $d->[2],
			});
		}
		$res{$dep} = \@deps;
	}

	while (my ($script, $tag) = each(%script2tag)) {
		my $s = query_single($rpm, $tag);
		next unless $s && $s ne "(none)";
		my $interp = query_single($rpm, "${tag}prog");
		$res{$script} = {
			interp => $interp,
			script => $s,
		};
	}
	open(my $fh, '-|', "rpm", "-qp", "--changelog", $rpm) or die "rpm: $!\n";
	{
		local $/ = undef;
		my $changelog = <$fh>;
		close($fh);
		$res{changelog} = $changelog;
	}

	return \%res;
}

sub print_package {
	my ($p, $is_main) = @_;

	if ($is_main) {
		print SPEC "Name: $p->{name}\n";
		print SPEC "Buildroot: $directory\n";
		print SPEC "\%define _use_internal_dependency_generator 0\n";
		print SPEC "\%define __find_provides /bin/true\n";
		print SPEC "\%define __find_requires /bin/true\n";
		print SPEC "\%define __find_supplements /bin/true\n";
		print SPEC "\%define __find_provides /bin/true\n";

	} else {
		print SPEC "\%package -n $p->{name}\n";
	}
	for my $tag (qw(version release license group summary)) {
		print SPEC "$tag: $p->{$tag}\n";
	}
	print SPEC "BuildArch: noarch\n" if $p->{arch} eq "noarch";
	for my $dep (keys(%dep2tag)) {
		print_deps($dep, $p->{$dep});
	}
	print SPEC "\%description -n $p->{name}\n";
	print SPEC "$p->{description}\n\n";

	for my $script (keys(%script2tag)) {
		next unless $p->{$script};
		my $file = "$script-$p->{name}";
		open(my $fh, '>', "$output/$file") or die "$output/$file: $!\n";
		print SPEC "\%$script -p $p->{$script}{interp} -n $p->{name} -f $file\n";
		print $fh $p->{$script}{script};
		close($fh);

	}
	if ($p->{files}) {
		print SPEC "\%files -n $p->{name}\n";
		print_files($p->{files});
	}
	print SPEC "\n";
}

# /usr/include/rpm/rpmds.h
my %deptypes = (
	pre    => (1 <<  9),
	post   => (1 << 10),
	preun  => (1 << 11),
	postun => (1 << 12),
	verify => (1 << 13),

	rpmlib => (1 << 24),
);

sub print_deps {
	my ($depname, $list) = @_;

	foreach my $d (@$list) {
		use Data::Dumper;
		#print STDERR Dumper($d);
		next if ($d->{flags} & $deptypes{rpmlib});

		print SPEC "$depname";
		my @deptypes;
		while (my ($type, $bit) = each(%deptypes)) {
			push(@deptypes, $type) if $d->{flags} & $bit;
		}
		print SPEC "(", join(",", @deptypes), ")" if @deptypes;
		print SPEC ": ";

		print SPEC $d->{name};
		if ($d->{version}) {
			print SPEC " ";
			print SPEC "<" if $d->{flags} & (1 << 1); # RPMSENSE_LESS
			print SPEC ">" if $d->{flags} & (1 << 2); # RPMSENSE_GREATER
			print SPEC "=" if $d->{flags} & (1 << 3); # RPMSENSE_EQUAL
			print SPEC " $d->{version}";
		}
		print SPEC "\n";
	}
}

sub print_files {
	my $files = shift;

	for my $f (@$files) {
		my $attrs = "";
		$attrs .= "\%dir " if S_ISDIR($f->{mode});
		$attrs .= sprintf('%%attr(%04o, %s, %s) ', ($f->{mode} & 0777),
			$f->{owner}, $f->{group});
		if ($f->{flags} & 1) {
			$attrs .= "%config ";
			$attrs .= "(noreplace) " if $f->{flags} & 16;
		}
		$attrs .= "%doc " if $f->{flags} & 2;
		$attrs .= "%ghost " if $f->{flags} & 64;
		print SPEC "$attrs $f->{name}\n";
		if (-e "$directory/$f->{name}.sig") {
			print SPEC "$attrs $f->{name}.sig\n";
		}
	}
}

my %packages;
for my $rpm (@rpms) {
	my $p = load_package($rpm);
	$packages{$p->{name}} = $p;
}

my $sourcerpm;
for my $p (values(%packages)) {
	$sourcerpm = $p->{sourcerpm} unless $sourcerpm;
	if ($p->{sourcerpm} ne $sourcerpm) {
		die "Error: packages built from different source rpm: $sourcerpm vs $p->{sourcerpm}\n";
	}
}
if ($sourcerpm !~ /^(.+)-([^-]+)-([^-]+)\.src\.rpm$/) {
	die "Error: malformed %{sourcerpm} tag: $sourcerpm\n";
}
my ($main_name, $main_ver, $main_rel) = ($1, $2, $3);
if (!exists($packages{$main_name})) {
	# create an empty main package, only the NVR and changelog matters
	my $first = (values(%packages))[0];
	$packages{$main_name} = {
		name => $main_name,
		version => $main_ver,
		release => $main_rel,
	};
	for my $tag (qw(license group summary description changelog)) {
		$packages{$main_name}->{$tag} = $first->{$tag};
	}
}

open(SPEC, '>', "$output/repackage.spec") or die "$output/repackage.spec: $!\n";
print_package($packages{$main_name}, 1);
for my $p (values(%packages)) {
	next if $p->{name} eq $main_name;
	print_package($p, 0);
}
print SPEC "\%changelog\n";
print SPEC $packages{$main_name}->{changelog};
close(SPEC);
