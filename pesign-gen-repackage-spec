#!/usr/bin/perl

use strict;
use warnings;

my $USAGE = "Usage: $0 --directory <payload directory> rpm...\n";

use Getopt::Long;
use Fcntl qw(:mode);

my $directory;
my @rpms;

GetOptions(
	"help|h" => sub { print $USAGE; exit; },
	"directory|d=s" => \$directory,
) or die $USAGE;
@rpms = @ARGV;
if (!@rpms) {
	print STDERR "$0: No packages given\n";
	die $USAGE;
}
if (!$directory || substr($directory, 0, 1) ne '/' || ! -d $directory) {
	print STDERR "$0: --directory must be an absolute path\n";
	die $USAGE;
}

sub query_array {
	my ($rpm, @tags) = @_;
	my @res;

	my $format = "[" . join("|", map { "\%{$_}" } @tags) . "\\n]";
	open(my $fh, '-|', "rpm", "-qp", "--qf", $format, $rpm)
		or die "rpm: $!\n";
	while (<$fh>) {
		chomp;
		my @t = split(/\|/, $_, -1);
		push(@res, \@t);
	}
	close($fh);
	return @res;
}

sub query_single {
	my ($rpm, $tag) = @_;
	my $res;

	open(my $fh, '-|', "rpm", "-qp", "--qf", "\%{$tag}\\n", $rpm)
		or die "rpm: $!\n";
	{
		local $/ = undef;
		$res = <$fh>;
	}
	chomp $res;
	close($fh);
	return $res;

}

# specfile dependency => rpm tag name
my %dep2tag = (
	conflicts => "conflict",
	obsoletes => "obsolete",
	provides => "provide",
	requires => "require",
	suggests => "suggests",
	supplements => "enhances",
);

sub load_package {
	my $rpm = shift;
	my %res;

	for my $tag (qw(name version release arch sourcerpm license group summary description)) {
		$res{$tag} = query_single($rpm, $tag);
	}
	my @files;
	my @list = query_array($rpm, qw(filenames fileflags filemodes fileusername filegroupname filesizes));
	for my $file (@list) {
		push(@files, {
				name => $file->[0],
				flags => $file->[1],
				mode => $file->[2],
				owner => $file->[3],
				group => $file->[4],
				size => $file->[5],
		});
	}
	$res{files} = \@files;
	while (my ($dep, $tag) = each(%dep2tag)) {
		my @deps;
		my @list = query_array($rpm, "${tag}name", "${tag}flags", "${tag}version");
		for my $d (@list) {
			push(@deps, {
					name => $d->[0],
					flags => $d->[1],
					version => $d->[2],
			});
		}
		$res{$dep} = \@deps;
	}

	return \%res;
}

my %packages;
for my $rpm (@rpms) {
	my $p = load_package($rpm);
	$packages{$p->{name}} = $p;
}

my $sourcerpm;
for my $p (values(%packages)) {
	$sourcerpm = $p->{sourcerpm} unless $sourcerpm;
	if ($p->{sourcerpm} ne $sourcerpm) {
		die "Error: packages built from different source rpm: $sourcerpm vs $p->{sourcerpm}\n";
	}
}
if ($sourcerpm !~ /^(.+)-([^-]+)-([^-]+)\.src\.rpm$/) {
	die "Error: malformed %{sourcerpm} tag: $sourcerpm\n";
}
my ($main_name, $main_ver, $main_rel) = ($1, $2, $3);
if (!exists($packages{$main_name})) {
	# create an empty main package, only the NVR matters
	my $first = (values(%packages))[0];
	$packages{$main_name} = {
		name => $main_name,
		version => $main_ver,
		release => $main_rel,
	};
	for my $tag (qw(license group summary description)) {
		$packages{$main_name}->{$tag} = $first->{$tag};
	}
}

sub print_package {
	my ($p, $is_main) = @_;

	if ($is_main) {
		print "Name: $p->{name}\n";
		print "Buildroot: $directory\n";
		print "\%define _use_internal_dependency_generator 0\n";
		print "\%define __find_provides /bin/true\n";
		print "\%define __find_requires /bin/true\n";
		print "\%define __find_supplements /bin/true\n";
		print "\%define __find_provides /bin/true\n";

	} else {
		print "\%package -n $p->{name}\n";
	}
	for my $tag (qw(version release license group summary)) {
		print "$tag: $p->{$tag}\n";
	}
	for my $dep (keys(%dep2tag)) {
		print_deps($dep, $p->{$dep});
	}
	print "\%description -n $p->{name}\n";
	print "$p->{description}\n\n";

	if ($p->{files}) {
		print "\%files -n $p->{name}\n";
		print_files($p->{files});
	}
	print "\n";
}

# /usr/include/rpm/rpmds.h
my %deptypes = (
	pre    => (1 <<  9),
	post   => (1 << 10),
	preun  => (1 << 11),
	postun => (1 << 12),
	verify => (1 << 13),

	rpmlib => (1 << 24),
);

sub print_deps {
	my ($depname, $list) = @_;

	foreach my $d (@$list) {
		use Data::Dumper;
		#print STDERR Dumper($d);
		next if ($d->{flags} & $deptypes{rpmlib});

		print "$depname";
		my @deptypes;
		while (my ($type, $bit) = each(%deptypes)) {
			push(@deptypes, $type) if $d->{flags} & $bit;
		}
		print "(", join(",", @deptypes), ")" if @deptypes;
		print ": ";

		print $d->{name};
		if ($d->{version}) {
			print " ";
			print "<" if $d->{flags} & (1 << 1); # RPMSENSE_LESS
			print ">" if $d->{flags} & (1 << 2); # RPMSENSE_GREATER
			print "=" if $d->{flags} & (1 << 3); # RPMSENSE_EQUAL
			print " $d->{version}";
		}
		print "\n";
	}
}

sub print_files {
	my $files = shift;

	for my $f (@$files) {
		my $attrs = "";
		$attrs .= "\%dir " if S_ISDIR($f->{mode});
		$attrs .= sprintf('%%attr(%04o, %s, %s) ', ($f->{mode} & 0777),
			$f->{owner}, $f->{group});
		if ($f->{flags} & 1) {
			$attrs .= "%config ";
			$attrs .= "(noreplace) " if $f->{flags} & 16;
		}
		$attrs .= "%doc " if $f->{flags} & 2;
		$attrs .= "%ghost " if $f->{flags} & 64;
		print "$attrs $f->{name}\n";
		if (-e "$directory/$f->{name}.sig") {
			print "$attrs $f->{name}.sig\n";
		}
	}
}

print_package($packages{$main_name}, 1);
for my $p (values(%packages)) {
	next if $p->{name} eq $main_name;
	print_package($p, 0);
}
